<section>

  <h1>Phase 3: Parsing Tokens into a Parse Tree</h1>

  <pre>
    <code class="hljs language-python";
	  style="width: 600px;">"""
BlackHat Asia Example
"""</code>
    </pre>

  <p style="font-size: 20px">Constructing Parse Tree from Tokens:</p>
  <pre>
    <code class="hljs language-pyasm";
	  style="width: 600px;"> LOAD_STR   '\nBlackHat Asia Example\n'
 STORE_NAME __doc__</code>
  </pre>

  <p class="fragment" style="font-size: 20px">Is parsed:</p>
    <pre class="fragment">
      <code class="hljs language-pyasm"> LOAD_STR</code>
    </pre>
    <pre class="fragment">
      <code class="hljs language-grammar"> expr  ::= LOAD_STR</code>
    </pre>
    <div class="fragment">
      <img data-src="images/dot/assign-expr.png"/>
    </div>


    <aside class="notes">
      <div style="color: blue; background-color:
		  LightYellow">#/11</div>
      <p>
	In the last slide, we showed the first two phases of
	decompilation. Those phases turned bytecode <em>bytes</em> into
	bytecode <em>instructions</em>, and then into a stream of
	<em>tokens</em>. The process next of scanning and parsing, that
	I will show now, will look familiar to those who have developed
	compilers. But that is kind of a niche market, so I suspect that
	for many of you, <em>this</em> will be new. If things go too
	quickly, you may find some of this explained in one of those
	compiler books of the images I showed earlier.
      </p>

      <p>
	To simplify things, we will focus on just the source text from
	the very first line. Even though this is a <em>small</em> part
	of the code, it covers <em>all</em> of the the basic
	concepts <em>very</em> well.
      </p>

      <p>
	The companion materials has more detail if you want to see more
	complex examples. But in order to run, it helps to walk
	first. So let's start out with first line of the Python
	program. It was just a simple Python docstring shown in green at
	the top.</p>

      <p>And let's start out with the first instruction.
	<div style="color: blue; background-color:
		    LightYellow">[DOWN] [DOWN]
	  #/11 ⟶ #/11/0/1</div></p>

      <p>
	Note that we just use the token name "LOAD_STR". The string
	<em>value</em> isn’t relevant in parsing.
      </p>

      <p>
	That one instruction, all by itself, is the complete
	representation in bytecode for a particular Python expression!
	Here, it would be what Python will produce for a literal string
	expression, "Blackhat Asia Example", with nothing else.
      </p>

      <p>
	For those of you who are familiar with programming-language
	systems that compile to <em>machine</em> code, again, this is
	strange.  In machine code, you rarely have <em>one</em>
	instruction fully covering one source-code expression. That's
	what makes this <em>high-level</em> bytecode.
      </p>

      <p>
	Of course, many or most Python expressions require more than
	one instruction to represent them in
	bytecode.
	<div style="color: blue; background-color:
		    LightYellow">[DOWN] #11/0/1 ⟶ #11/0/2</div>
      </p>

      <p>
	Because "LOAD_STR" is a complete expression, the parser matches
	that single token and emits a quote unquote "grammar reduction
	rule". This is the "expr colon colon LOAD_STR" you see
	here. This line is written in Backus-Naur Form. You will see
	this notation used in both Python's grammar specification and
	its Abstract Syntax Tree specification.  More generally, this is
	the way syntax is specified in most programming languages.
      </p>

      <p>
	But the decompilers I've written <em>also</em> use grammars to
	do their work. And this is one of the 50 or so grammar rules for
	decompiling Python 3.8.
      </p>

      <p>
	The word to the right of "::="" in yellow is called
	a <em>grammar symbol</em> . The "colon colon equal" is
	pronounced "transforms into" because an "expr" grammar symbol
	can "transform into" a LOAD_STR token. But since we are
	working bottom up (or token up), the parser recognizes this
	reduction possibility only <em>after</em> the fact. So the
	recognition is from the right to left, or alternatively, from
	the token to grammar symbol...
	<div style="color: blue; background-color: LightYellow">[DOWN]
	  #11/0/2 ⟶ #11/0/3]
	</div>
     </p>

      <p>
	In performing this reduction rule, the parser creates a simple
	tree created with the "expr" grammar symbol in yellow as a
	root node of this tree, and "LOAD_STR" token in blue is its
	single child.  Now let's continue...
	<div style="color: blue; background-color: LightYellow">[DOWN]
	  #11/0/3 ⟶ #11/1]</div>
      </p>

  </aside>

</section>
<section>

  <h1>Parsing Tokens into a Parse Tree (Part 2)</h1>

  <p style="font-size: 20px">Constructing Parse Tree from Tokens:</p>
  <pre style="line-height: 0.5em">
    <code class="hljs language-pyasm"> LOAD_STR</code>
    <code class="hljs language-grammar"> expr  ::= LOAD_STR</code>
  </pre>
  <pre style="line-height: 0.5em" class="fragment">
      <code class="hljs language-pyasm"> STORE_NAME</code>
  </pre>
  <pre style="line-height: 0.5em" class="fragment">
    <code class="hljs language-grammar"> store   ::= STORE_NAME</code></pre>
  <div class="fragment">
    <img data-src="images/dot/assign-store.png"/>
  </div>

  <aside class="notes">
    <div style="color: blue; background-color:
    LightYellow">#/11/1</div>
    <p>
      Here, I've just copied what we had before. Now let us get to the
      next bytecode instruction.  <div style="color: blue;
      background-color: LightYellow">[DOWN] #11/1 ⟶ #11/1/0]</div>
    </p>

    <p>
      A "STORE_NAME" instruction is one of the tokens that fully forms
      "store" grammar symbol.  <div style="color: blue;
      background-color: LightYellow">[DOWN] #/11/1/0 ⟶ #11/1/1]</div>
    </p>

    <p>
      Although you won't find a "store" grammar symbol in a grammar
      for Python, you will find "store" with a capital "S" appearing
      in Python's AST documentation. "expr" with a capital E is also
      appears in Python's AST.
    </p>

    <p>
      When possible, we try to use the grammar-symbol names that are
      similar to the names that Python's AST uses. The two are
      similar, but they have to be different.
    </p>

    <p>
      <em>If</em> instead of "STORE_NAME" we had "STORE_GLOBAL" , that
      would be another kind of instruction in the class of "store"
      grammar symbols.  In English, think of how a noun could be one
      of many words, like "bike", "car", or "bus". Let’s say that
      "STORE_NAME" is like "bike", while "STORE_GLOBAL" is like
      "car". As far as a sentence goes, bikes and cars are
      both <em>nouns</em>; "noun" is the grammar symbol that they both
      belong to. The grammar <em>structure</em> of a sentence does not
      change when you replace "bus" for "car" in that sentence.
    </p>

    <p>
      To recap, we have now encountered two reduction rules; these are
      lines with yellow to the left. After this second rule is
      encountered, the little graph that the parser has been building
      looks like this: ... <div style="color: blue; background-color:
      LightYellow">[DOWN] #/11/1/1 ⟶ #11/1/2</div>
    </p>

    <p>
      We now have two little trees. So let's continue...
      <div style="color: blue; background-color:
		  LightYellow">[DOWN] #/11/1/2 ⟶ #11/2
      </div>
    </p>


  </aside>

</section>

<section>

  <h1>Parsing Tokens into a Parse Tree (Part 3)</h1>

  <pre style="line-height: 0.5em">
    <code class="hljs language-pyasm"> LOAD_STR</code>
    <code class="hljs language-grammar"> expr  ::= LOAD_STR</code>
    <code class="hljs language-pyasm"> STORE_NAME</code>
    <code class="hljs language-grammar"> store   ::= STORE_NAME</code>
  </pre>

  <pre class="fragment"><code class="hljs language-grammar"> assign  ::= expr store</code></pre>
  <div class="fragment">
    <img data-src="images/dot/assign-assign.png"/>
  </div>
  <aside class="notes">
    <div style="color: blue; background-color:
    LightYellow">#/11/2</div>
    <p>
      Again, the parser has matched "expr" and "store" grammar
      symbols, and built these trees for them.
      <div style="color: blue; background-color: LightYellow">[DOWN]
      #/11/2 ⟶ #11/2/0</div></p>

    <p>After finishing with the "store" reduction rule, the parser now
      notices that we have matched "expr" and "store" grammar symbols
      in succession. The grammar I wrote for the decompilers dictate
      that when these two are seen in succession, that constitutes an
      assignment statement. So another rule triggers.
      <div style="color: blue; background-color:
      LightYellow">[DOWN] #/11/2/0 ⟶ #/11/2/1</div>
    </p>

    <p>
      And the two trees that we had before are joined.
      <div style="color: blue; background-color: LightYellow">[DOWN]
	#/11/2/1 ⟶ #/11/3</div>
    </p>
  </aside>

</section>

<section>

  <h1>Parsing Tokens into a Parse Tree (Part 4)</h1>

  <pre style="line-height: 0.5em">
    <code class="hljs language-pyasm"> LOAD_STR</code>
    <code class="hljs language-grammar"> expr  ::= LOAD_STR</code>
    <code class="hljs language-pyasm"> STORE_NAME</code>
    <code class="hljs language-grammar"> store   ::= STORE_NAME</code>
    <code class="hljs language-grammar"> assign  ::= expr store</code></pre>

  <pre class="fragment">
    <code class="hljs language-grammar"> stmts   ::= assign</code>
  </pre>
  <div class="fragment">
    <img data-src="images/dot/assign-stmt.png"/>
  </div>

  <aside class="notes">
    <div style="color: blue; background-color:
		LightYellow">#/11/3</div>
    <p>
      Again, to recap: We matched an assignment
      statement. <div style="color: blue; background-color:
      LightYellow">[DOWN] #/11/3 ⟶ #/11/3/0</div>
    </p>

    <p>
      Continuing, an assignment statement is a kind of statement. And
      we have a grammar rule to indicate that.</p>

    <p>Notice that after seeing the second token "STORE_NAME" in blue
      from early on, we kicked off a flurry of reduction rules. This
      kind of thing happens in bottom-up parsers when you get to the
      end of the token stream. It is like a detective story where, in
      the last couple of pages, all of the loose fragments and
      mysteries of the story from the very beginning are finally
      wrapped up. <div style="color: blue; background-color:
      LightYellow">[DOWN] #/11/3/0 ⟶ #/11/3/1</div>
   </p>

    <p>
      Here is the final tree... And now let's see how this is shown as
      ASCII debug output... <div style="color: blue; background-color:
      LightYellow">[DOWN] #/11/3/1 ⟶ #/11/4</div>
    </p>
  </aside>
</section>

<section>
  <h1>Phases 3 - 5: Final Parse Tree to Source Text</h1>
  <p>Phase 3. Parse Tree in ASCII Format (First Line):</p>
    <pre>
      <code class="hljs language-decompile";
	    style="width: 700px;"> stmts
   0. assign
       0. expr
           L.  1   0  LOAD_STR    '\nBlackHat Asia Example\n'
       1. store
                   2  STORE_NAME   __doc__
      </code>
    </pre>
  <span class="fragment">
    <p>Phase 4. Abstract Syntax Tree (First Line)</p>
    <pre>
      <code class="hljs language-decompile";
	    style="width: 700px;"> stmts
  0. docstring
        0  LOAD_STR    '\nBlackHat Asia Example\n'
        2  STORE_NAME  __doc__</code>
    </pre>
    <div class="fragment">
      <p>Phase 5. Printing the Abstract Syntax Tree (First line)</p>
      <pre>
	<code class="hljs language-decompile";
	      style="width: 600px;">"""
BlackHat Asia Example
"""</code>
      </pre>
    </div>
  </span>

  <aside class="notes">
    <div style="color: blue; background-color:
    LightYellow">#/11/4</div>
    <p>This is an ASCII representation of the graph from the last
      slide.  It shows more information shown than the graph.  But that
      is because we are also showing token <em>attributes</em> in
      addition to the token <em>names</em>.
    </p>

    <p>
      For example, we now see instruction offsets and instruction
      operand values. Grammar parsing just uses token <em>names</em>,
      but tokens themselves, do store these other bits of information.
    </p>

    <p>
      All of this is good, but recall that we didn’t actually have an
      assignment statement at the top of the source text. Instead,
      what we had was a docstring!  However, docstrings are
      <em>implemented</em> in Python by creating a <em>special</em>
      kind of assignment to string variable with that funny name:
      "__doc__".
    </p>

    <p>
      So where does this get changed into something more familiar?  I’m
      glad you asked! Because, this comes in the next phase
      ... <div style="color: blue; background-color:
      LightYellow">[DOWN] #/11/4 ⟶ #/11/4/0</div>
    </p>

    <p>
      Phase 4 takes the parse tree we just created and transforms
      that into an Abstract Syntax Tree: we look for tree patterns
      like this special kind of assignment statement. When the process
      finds something of interest that matches, that part of the tree
      is replaced. In a sense, we are "abstracting" the specifics we
      found into something that is more the way the Python programmer
      wrote the program.</p>

    <p>
      Strictly speaking, we don't have to do this here, and sometimes
      kind of thing can be a difference between
      the <em>reconstructed</em> and the <em>original</em> source
      text. However, If you find Python source text that looks screwy
      or isn’t even valid Python, what may be going on is that this
      kind of transformation isn’t being detected.
    </p>

    <p>
      Notice that we have also simplified the tree as well. We no
      longer have grammar symbols "expr" or "store".
    </p>

    <p>
      We could have tried to detect docstrings earlier, but that would
      have been messier.
    </p>

    <p>
      And <em>finally</em> we get to that actual source text.  The
      source text is created by traversing this AST, calling routines
      based on the name of the grammar symbol, here the grammar symbol
      name is "docstring" in yellow. <div style="color: blue;
      background-color: LightYellow">[DOWN] #/11/4/0 ⟶ #/11/4/1</div>
    </p>

    <p>
      To simplify the conversion of the AST to a source string, there
      is a custom domain-specific language or DSL used. This DSL is
      described in the project wiki. <div style="color: blue;
      background-color: LightYellow">[NEXT] #/11/4/1 ⟶ #/12</div>
    </p>


  </aside>
</section>
