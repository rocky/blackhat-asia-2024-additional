<section>
  <h1>Bytecode Disassembly</h1>
    <pre style="margin-left: 0px; line-height: 20px;">
      <code
	style="font-size: 60%">  0 |64 00 5a 00 64 01 64 02 |
  8 |84 00 5a 01 65 02 65 00 |
 16 |83 00 83 01 01 00 64 03 |
 24 |53 00                   |</code>
    </pre>
  <p class="fragment" style="font-size: smaller">Disassembly using
    <code class="hljs-code" style="font-size: smaller">pydisasm</code> from
    <code class="hljs-title" style="font-size: smaller">xdis</code>:
  </h1>

  <p class="fragment" style="line-height: 40px; font-size: 40%">
    <code  class="hljs language-shell";
	   style="width: 600px; font-size: smaller;">
      <span class="hljs-meta prompt_">$</span>
      <span class="hljs-code">pydisasm</span>
      <span class="hljs-selector-id">-F extended-bytes -S</span>
      <span class="hljs-variable">__pycache__/five.cpython-38.pyc</span>
    </code>

    <aside class="notes">
      <div style="color: blue; background-color:
    LightYellow">#/13</div>
      <p>I’m going to focus a little more on disassembly for one
	important reason: There aren’t good decompilers for the
	most-recent Python-bytecode versions. And that
	is <em>likely</em> to continue forever. So the
	reality is: you may have to understand bytecode malware from a
	disassembly listing.
      </p>

      <p>
	There is a disassember in the standard Python Library
	called <em>dis</em>. Most novice decompilers use this &mdash;
	it's the first thing that comes to mind. But that has some
	serious limitations.  The biggest limitation is that it can
	only disassemble code for a <em>single</em> Python version,
	the version that runs the decompiler. If you are running the
	latest version of Python, such 3.12, but the bytecode you want
	to analyze is from an earlier version, like bytecode from 2.7,
	then you are out of luck.  Malware written in Python, tends to
	use <em>older</em> versions of Python. This was the situation
	when Microsoft folks contacted me.
	<div style="color: blue; background-color:
		    LightYellow">[DOWN] #/13 ⟶ #/13/0/0</div>
      </p>

      <p>To get around this limitation, <em>uncompyle6</em>
	and <em>decompile3</em> use <em>xdis</em> &mdash; the
	"<em>cross</em>-Python <em>dis</em>-assembler".
      </p>


      <p>
	<em>xdis</em> has a disassembler on steroids that I’m going to
	show now briefly.
	<div style="color: blue; background-color: LightYellow">[DOWN]
	  #/13/0/0 ⟶ #/13/0/1</div>
      </p>

      <p>
	Command-line options in yellow of the disassembler that I use in this
	invocation are:
	<ul>
	  <li>basic interpretation of <em>sequences</em> of
	    instructions</li>
	  <li>showing the actual bytecode</li>
	  <li>the ability to intermingle the source-code text with
	    assembly.</li>
	</ul>
      </p>

    <p>
      In reverse engineering, most of the time you will not have the
      source text. There is, of course, no harm in asking for source
      text when it doesn’t exist.  Now let's look at the
      output.
      <div style="color: blue; background-color: LightYellow">[DOWN]
	#/13/0/1 ⟶ #/13/1
      </div>
    </p>

  </aside>
</section>

<section>
  <h1>Bytecode Disassembly</h1>
    <pre style="margin-left: 0; line-height: 20px; width: 800px">
      <code
	class="hljs language-apache">  0 |64 00 5a 00 64 01 64 02 |
  8 |84 00 5a 01 65 02 65 00 |
 12 |65 02 65 01 83 01 01 00 |
 16 |83 00 83 01 01 00 64 03 |
 24 |53 00                   |</code>
    </pre>

  <p style="line-height: 40px; font-size: 40%">
    <code  class="hljs language-shell"
		   style="width: 800px; font-size: smaller;">
      <span class="hljs-meta prompt_">$</span>
      <span class="hljs-code">pydisasm</span>
      <span class="hljs-selector-id">-F extended-bytes -S</span>
      <span class="hljs-variable">__pycache__/five.cpython-38.pyc</span>
    </code>
  </p>

    <pre>
      <code
	data-line-numbers="1-10|2-3|2-3,7-8,11-13|11|3,12|8,13|8,12,13|21-25"
	class="hljs language-pyasm"
	style="width: 800px; margin-left: -48px; line-height: 20px"># ...
# Constants:
#    0: '\nBlackHat Asia Example\n'
#    1: &lt;code object five at 0x7f64cb56c030, file "five.py", line 6&gt;
#    2: 'five'
#    3: None
# Names:
#    0: __doc__
#    1: five
#    2: print
       # """\nBlackHat Asia Example\n"""
 1:      0 |64 00| LOAD_CONST        ("\nBlackHat Asia Example\n")
         2 |5a 00| STORE_NAME        (__doc__) ; __doc__ = '\nBlackHat Asia Example\n'

       # def five():
 6:      4 |64 01| LOAD_CONST        (&lt;code object five at 0x7f64cb56c030, file "five.py&gt;)
         6 |64 02| LOAD_CONST        ("five")
         8 |84 00| MAKE_FUNCTION     (No arguments) ; TOS = def five(...): ...
        10 |5a 01| STORE_NAME        (five) ; five = def five(...): ...

       # print(five())
12:     12 |65 02| LOAD_NAME         (print)
        14 |65 01| LOAD_NAME         (five)
        16 |83 00| CALL_FUNCTION     (0 positional arguments) ; TOS = five()
        18 |83 01| CALL_FUNCTION     (1 positional argument) ; TOS = print(five())
        20 |01 00| POP_TOP
        22 |64 03| LOAD_CONST        (None)
        24 |53 00| RETURN_VALUE      return None


# Method Name:       five
# Filename:          five.py
# Argument count:    0
# Position-only argument count: 0
# Keyword-only arguments: 0
# Number of locals:  0
# Stack size:        1
# Flags:             0x00000043 (NOFREE | NEWLOCALS | OPTIMIZED)
# First Line:        6
# Constants:
#    0: 'Returns the string five'
#    1: '5'
       # def five():
 8:      0 |64 01| LOAD_CONST           ("5")
         2 |53 00| RETURN_VALUE         return "5"
      </code>
    </pre>

    <aside class="notes">
      <div style="color: blue; background-color:
		  LightYellow">#/13/1</div>
      <p>
	At the top, again, is some metadata in orange. I went into some
	of this earlier, so I have elided this in the slide.
	<div style="color: blue; background-color: LightYellow">[DOWN]
	  #/13/1 ⟶ #/13/1/0
	</div>
      </p>

      <p>
	A piece of metadata that we saw <em>implicitly</em> before, was
	this value from this constants table.
	<div style="color: blue; background-color: LightYellow">[DOWN]
	  #/13/1/0 ⟶ #/13/1/1
	</div>
	The first instruction at offset 0 is "LOAD_CONST". The string
	operand of this instruction came from index zero of this
	constants table.  Now let's compare the assembly instructions.
      </p>

      <p>
	If you are familiar with Python's <em>dis</em> output, this is
	similar. But there is more information.
	<div style="color: blue; background-color: LightYellow">[DOWN] #/13/1/1 ⟶ #/13/1/2
	</div>
	First, we see the Python source text, in green, for line 1. It
	is that Python docstring.
	<div style="color: blue; background-color: LightYellow">[DOWN]
	  #/13/1/2 ⟶ #/13/1/3
	</div>
      </p>

      <p>
	Below that, in white, we have, between vertical bars, the actual
	bytecode values. This is also at the top of the slide in
	hex.</p>

      <p>
	The first byte of the first instruction is hex 64. This is the
	opcode in Python 3.8, for "LOAD_CONST". The operand value is 0,
	but 0, again, is an index into that orange constants table
	above.
	<div style="color: blue; background-color:
		    LightYellow">[DOWN] #/13/1/3 ⟶ #/13/1/4</div>
      </p>

      <p>
	In the second instruction, we see something interesting
	happening off to the far right...  This is after the
	parenthesized operand value, <em>__doc__</em> in green. There is
	additional text &mdash; an assignment statement that starts in
	white: <pre>__doc__ = 'BlackHat Asia Example'</pre>
	<div style="color: blue; background-color:
		    LightYellow">[DOWN] #/13/1/4 ⟶ #/13/1/5</div>
      </p>

      <p>
	Here, the disassembler is describing the <em>combined</em>
	effect of the first
	<em>two</em> lines. As I mentioned before, this is how Python
	implements docstrings.
	<div style="color: blue; background-color: LightYellow">[DOWN]
	  #/13/1/5 ⟶ #/13/1/6
	</div>
      </p>

      <p>
	Here is a more complicated example. Companion materials explain
	this in more detail.
      </p>

      <p>
	Don't get confused between <em>disassembly</em>
	and <em>decomplation</em>. Even though there is some
	higher-level interpretation, what we have here is a
	<em>disassembly</em>. Internals of the interpreter are
	exposed. For example, the "Top of Stack" or "toss equal" refers
	how the <em>interpreter</em> works. And the "POP_TOP"
	instruction which is greyed out, just below the last
	CALL_FUNCTION has no corresponding meaning in the source
	code.
      </p>

      <p>
 	Disassembly is easy and straight-forward. Decompilation is
	hard. However, decompilation starts out with a disassembly.

	<div style="color: blue; background-color: LightYellow">[NEXT] #/13/1/6 ⟶ #/13/2</div>
      </p>

  </aside>
</section>
