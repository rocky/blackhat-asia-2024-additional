<section>
  <h1>Disassembly explained</h1>
  <p class="small" line-height="40px">
    <pre>
      <code  class="hljs language-shell";
	     style="width: 700px;">$ python -m dis five.py</code>
    </pre>

    <pre>
      <code class="hljs language-pyasm" style="width: 700px;">line offset operand (accessed-value)

	1           0 LOAD_CONST               0&nbsp;('\nBlackHat Asia Example 1\n')
      </code>
    </pre>
  </p>

  <aside class="notes">
    <p>Decompilers start out with input of some sort. For Python decompilers, the input is Python bytecode. From the bytecode you get a disassembly listing.</p>

    <p>Don't get confused: disassembly takes bytecode and produces bytecode <i>assembly</i> instructions. A decompiler takes bytecode and produces Python source code.</p>

    <p>The Standard Python <code>dis</code> module can be run to give a disassembly of bytecode. Here is an example of running that [down]</p>


    <p>In running <code>dis</code>  above, the Python <em>source</em> text is input. Internally <code>dis</code> then creates bytecode, and disassembles the bytecode. Although with <code>dis</code> you can't disassemble bytecode from the command-line, there are internal <code>dis</code> library routines that allow you to start out with just the bytecode. Writing such a command-line utility then isn't hard, but later, we will describe a better alternative.</p>

  </aside>
</section>
